from copy import deepcopy
from datetime import datetime, timedelta
from enum import Enum
import os
from os import PathLike
from pathlib import Path
from typing import Union

from nemspy import ModelingSystem

from coupledmodeldriver import Platform
from coupledmodeldriver.generate.schism.configure import (NEMSSCHISMRunConfiguration, SCHISMRunConfiguration)
from coupledmodeldriver.generate.schism.script import SchismRunJob
from coupledmodeldriver.script import SlurmEmailType
from coupledmodeldriver.utilities import (
    create_symlink,
    get_logger,
)

LOGGER = get_logger('cplmdldrv')


class RunPhase(Enum):
    """
    options for run phase of SCHISM execuction
    """

    COLDSTART = 'coldstart'
    HOTSTART = 'hotstart'


def generate_schism_configuration(
    configuration_directory: PathLike,
    output_directory: PathLike = None,
    relative_paths: bool = False,
    overwrite: bool = False,
    parallel: bool = True,
):
    """
    generate an SCHISM run configuration from JSON configuration files generated by ``initialize_schism``

    :param configuration_directory: path containing JSON configuration files
    :param output_directory: path to store generated configuration files
    :param relative_paths: whether to write relative paths in generated configuration files
    :param overwrite: whether to overwrite existing files
    :param parallel: generate configurations concurrently
    """

    start_time = datetime.now()

    if not isinstance(configuration_directory, Path):
        configuration_directory = Path(configuration_directory)

    if output_directory is None:
        output_directory = configuration_directory
    elif not isinstance(output_directory, Path):
        output_directory = Path(output_directory)

    output_directory = output_directory.resolve()
    if not output_directory.is_absolute():
        output_directory = output_directory.absolute()

    if not output_directory.exists():
        os.makedirs(output_directory, exist_ok=True)

    if configuration_directory.absolute().resolve() != Path.cwd():
        starting_directory = Path.cwd()
        os.chdir(configuration_directory)
        configuration_directory = Path.cwd()
    else:
        starting_directory = None

    use_nems = 'configure_nems.json' in [
        filename.name.lower() for filename in configuration_directory.iterdir()
    ]

    if use_nems:
        LOGGER.debug(f'generating NEMS configuration')
        base_configuration = NEMSSCHISMRunConfiguration.read_directory(configuration_directory)
    else:
        LOGGER.debug(f'generating SCHISM-only configuration')
        base_configuration = SCHISMRunConfiguration.read_directory(configuration_directory)

    base_configuration.move_paths(configuration_directory)

    platform = base_configuration['modeldriver']['platform']

    job_duration = base_configuration['slurm']['job_duration']
    slurm_account = base_configuration['slurm']['account']
    partition = base_configuration['slurm']['partition']
    email_type = base_configuration['slurm']['email_type']
    email_address = base_configuration['slurm']['email_address']

    # TODO create a SCHISM or NEMS + SCHISM configuration
    ...

    if starting_directory is not None:
        os.chdir(starting_directory)

    LOGGER.info(f'finished in {datetime.now() - start_time}')


def write_spinup_directory(
    directory: PathLike,
    configuration: Union[SCHISMRunConfiguration, NEMSSCHISMRunConfiguration],
    duration: timedelta,
    relative_paths: bool = False,
    overwrite: bool = False,
    platform: Platform = None,
    schism_processors: int = None,
    slurm_account: str = None,
    job_duration: timedelta = None,
    partition: str = None,
    email_type: SlurmEmailType = None,
    email_address: str = None,
) -> Path:
    """
    write an SCHISM tidal spinup configuration to the given directory

    :param directory: path to output directory
    :param configuration: run configuration
    :param duration: tidal spinup duration
    :param relative_paths: whether to write relative paths (instead of absolute)
    :param overwrite: whether to overwrite existing files
    :param platform: HPC platform to configure for
    :param schism_processors: number of processors to assign to SCHISM execution
    :param slurm_account: Slurm account name
    :param job_duration: wall-clock duration of Slurm job
    :param partition: Slurm partition name
    :param email_type: Slurm email notification option
    :param email_address: Slurm email notification address
    """

    if not isinstance(directory, Path):
        directory = Path(directory)

    if not directory.exists():
        directory.mkdir(parents=True, exist_ok=True)

    if not overwrite and configuration.files_exist(directory):
        LOGGER.warning(f'skipping existing directory "{directory}"')
        return directory

    job_name = 'SCHISM_COLDSTART_SPINUP'

    pyschism_driver = configuration.pyschism_driver

    if relative_paths:
        configuration.relative_to(directory, inplace=True)

    if 'nems' in configuration:
        nems = configuration.nemspy_modeling_system
        nems = ModelingSystem(
            nems.start_time - duration,
            nems.start_time,
            nems.interval,
            ocn=deepcopy(nems['OCN']),
            **nems.attributes,
        )
        processors = nems.processors
        model_executable = configuration['nems']['executable_path']
    else:
        nems = None
        processors = schism_processors
        model_executable = configuration['schism']['schism_executable_path']

    source_filename = configuration['schism']['source_filename']

    model_executable = update_path_relative(model_executable, relative_paths, directory)
    source_filename = update_path_relative(source_filename, relative_paths, directory)

    job_script_filename = directory / 'schism.job'

    job_script = SchismRunJob(
        platform=platform,
        slurm_tasks=processors,
        slurm_account=slurm_account,
        slurm_duration=job_duration,
        slurm_run_name=job_name,
        executable=model_executable,
        slurm_partition=partition,
        slurm_email_type=email_type,
        slurm_email_address=email_address,
        slurm_error_filename=f'{job_name}.err.log',
        slurm_log_filename=f'{job_name}.out.log',
        source_filename=source_filename,
    )

    job_script.write(job_script_filename, overwrite=overwrite)

    if 'nems' in configuration:
        LOGGER.debug(f'setting spinup to {duration}')

        nems.write(
            directory, overwrite=overwrite, include_version=True,
        )
        LOGGER.info(
            f'writing NEMS+SCHISM tidal spinup configuration to "{os.path.relpath(directory.resolve(), Path.cwd())}"'
        )
    else:
        LOGGER.debug(
            f'writing SCHISM tidal spinup configuration to "{os.path.relpath(directory.resolve(), Path.cwd())}"'
        )

    # TODO write pySCHISM driver write command here
    pyschism_driver.write(
        directory,
        overwrite=overwrite,
    )

    return directory


def write_run_directory(
    directory: PathLike,
    name: str,
    phase: str,
    configuration: Union[SCHISMRunConfiguration, NEMSSCHISMRunConfiguration],
    relative_paths: bool = False,
    overwrite: bool = False,
    platform: Platform = None,
    schism_processors: int = None,
    slurm_account: str = None,
    job_duration: timedelta = None,
    partition: str = None,
    email_type: SlurmEmailType = None,
    email_address: str = None,
    do_spinup: bool = False,
    spinup_directory: PathLike = None,
) -> Path:
    """
    write an SCHISM tidal spinup configuration to the given directory

    :param directory: path to output directory
    :param name: run name
    :param phase: SCHISM run phase
    :param configuration: run configuration
    :param relative_paths: whether to write relative paths (instead of absolute)
    :param overwrite: whether to overwrite existing files
    :param platform: HPC platform to configure for
    :param schism_processors: number of processors to assign to SCHISM execution
    :param slurm_account: Slurm account name
    :param job_duration: wall-clock duration of Slurm job
    :param partition: Slurm partition name
    :param email_type: Slurm email notification option
    :param email_address: Slurm email notification address
    :param do_spinup: whether to use spinup results to hotstart run
    :param spinup_directory: path to spinup directory
    """

    if not isinstance(directory, Path):
        directory = Path(directory)
    if spinup_directory is not None and not isinstance(spinup_directory, Path):
        spinup_directory = Path(spinup_directory)

    if not directory.exists():
        directory.mkdir(parents=True, exist_ok=True)
    LOGGER.debug(
        f'writing run configuration to "{os.path.relpath(directory.resolve(), Path.cwd())}"'
    )

    if not overwrite and configuration.files_exist(directory):
        LOGGER.warning(f'skipping existing directory "{directory}"')
        return directory

    job_name = f'SCHISM_{phase}_{name}'

    pyschism_driver = configuration.pyschism_driver

    if relative_paths:
        configuration.relative_to(directory, inplace=True)

    if 'nems' in configuration:
        nems = configuration.nemspy_modeling_system
        processors = nems.processors
        model_executable = configuration['nems']['executable_path']
    else:
        nems = None
        processors = schism_processors
        model_executable = configuration['schism']['schism_executable_path']

    source_filename = configuration['schism']['source_filename']

    model_executable = update_path_relative(model_executable, relative_paths, directory)
    source_filename = update_path_relative(source_filename, relative_paths, directory)

    job_script_filename = directory / 'schism.job'

    job_script = SchismRunJob(
        platform=platform,
        slurm_tasks=processors,
        slurm_account=slurm_account,
        slurm_duration=job_duration,
        slurm_run_name=job_name,
        executable=model_executable,
        slurm_partition=partition,
        slurm_email_type=email_type,
        slurm_email_address=email_address,
        slurm_error_filename=f'{job_name}.err.log',
        slurm_log_filename=f'{job_name}.out.log',
        source_filename=source_filename,
    )

    job_script.write(job_script_filename, overwrite=overwrite)

    if 'nems' in configuration:
        nems.write(
            directory, overwrite=overwrite, include_version=True,
        )
        LOGGER.info(
            f'writing NEMS+SCHISM run configuration to "{os.path.relpath(directory.resolve(), Path.cwd())}"'
        )
    else:
        LOGGER.debug(
            f'writing SCHISM run configuration to "{os.path.relpath(directory.resolve(), Path.cwd())}"'
        )

    # TODO write pySCHISM configuration
    pyschism_driver.write(
        directory,
        overwrite=overwrite,
    )

    if do_spinup:
        # TODO enumerate SCHISM hotstart filenames here
        for hotstart_filename in [...]:
            try:
                create_symlink(
                    spinup_directory / hotstart_filename,
                    directory / hotstart_filename,
                    relative=True,
                )
            except:
                LOGGER.warning(
                    f'unable to link `{hotstart_filename}` from coldstart to hotstart; '
                    'you must manually link or copy this file after coldstart completes'
                )

    return directory


def update_path_relative(
    path: PathLike, relative: bool = False, relative_directory: PathLike = None
) -> Path:
    """
    update the given path based on the given relative path

    :param path: input path
    :param relative: whether to use a relative path to the input path
    :param relative_directory: directory to use to update input directory
    :return: updated path
    """

    if path is not None:
        if not isinstance(path, Path):
            path = Path(path)
        if relative_directory is None:
            relative_directory = Path.cwd()
        if relative:
            if not isinstance(relative_directory, Path):
                relative_directory = Path(relative_directory)
            if path.is_absolute():
                path = Path(os.path.relpath(path, relative_directory))
        elif not path.is_absolute():
            path = (relative_directory / path).resolve().absolute()
    return path
